title: А ви любите Кафку?
background-image: url(transparent-grechka.jpg)
background-size: cover

<!--body
<script>
  var _CLICKED = null;
  document.body.addEventListener('click', function(e) {
    console.log(e);
    if (e.path[0].tagName == 'LI') {
      _CLICKED && _CLICKED.classList.remove('clicked');
      if (_CLICKED == e.path[0]) {
        _CLICKED = null;
      } else {
        _CLICKED = e.path[0];
        _CLICKED.classList.add('clicked');
      }
    }
  });
</script>
<style>
.remark-slide1 {
  width: 50%;
  left: 50%;
}
li.clicked {
  background-color: yellow;
}
</style>
-->

# .em2[Kafka]

<img style="display: block; height: 80%; margin: 0 auto;" src="kafka.svg">

---

# Шо парить

- Задача обробилась невірно - чому?..
--
- Де взяти повідомлень для розробки?
--
- Нова система? Будуй обміни даними ще з нею!
--
- Чорна п'ятниця вбила ERP кількістю замовлень
--
- Різні команди тичуть друг на друга при проблемах

---

# Чому так

- HTTP API - відстій
- Синхронні виклики треба використовувати *обмежено*
- Історія - це добре

---

# Кафка

- Тільки додавання даних (append-only)
- Історія повідомлень
- Великі швидкості на середньому залізі
- Це лог повідомлень, а не черга (MQ)

---

# Для чого

- Черга завдань
- Обмін даними між системами
- Розрив між генераторами навантаження і споживачами
- Помилки споживача не приводять до втрати даних

---

# Технічні перемоги

- Дебаг проблем стає простішим
- Легко розробляти на даних з проду
- Можна підключитися до існуючого потоку даних
- Різке зростання навантаження не вбиває сервіс

---

# Соціальні перемоги

- Причини збоїв шукаються не через обвинувачення, а через перегляд повідомлень
- Стабільність архітектури
  - Push чи pull? Хто кому клієнт?
  - Сервер помер, клієнт не робив retry?

---

background-image: url(transparent-grechka.jpg)
background-size: cover
class: middle

# .em2[Технічні подробиці]

---

# Головні сутності

- Топік - як файл з логами
- Повідомлення - строка у тому файлі
- Споживач - процес, який читає строки
- Офсет - номер строки для того процесу

---

# Як з цим працювати

- Ідемпотентність обробки
- Зворотня сумісність
- Схема
- 1 писар (producer) на 1 топік

---

background-image: url(transparent-grechka.jpg)
background-size: cover
class: middle

# .em2[Вовчі ями]

---

# Партиції

- Розділи топіків
- Спосіб масштабування навантаженого топіку
- Майже як окремі топіки
- Порядок між розділами не зберігається
- Повідомлення з 1 ключем попадають у 1 розділ

---

# Обробка помилок

- Зупинка обробки - для критичних помилок
- Запис повідомлення у кінець - для тимчасових
- Запис у сусідній топік (`*_error`) - для складних
- Запис у логи - для некритичних

---

# Запит/відповідь

- Кафка ідеальна для push-спілкування
- HTTP запит/відповідь ганяти через Кафку не треба
- Правило буравчика: Кафка ок, коли дія насправді асинхронна

---

# Нетронуті теми

- Надгробки (tombstones)
- Стискання (compaction)
- Інші просунуті речі, конфігурування, єтц

---

background-image: url(transparent-grechka.jpg)
background-size: cover
class: middle

# .em2[Глянемо навколо]

---

# Екосистема

- kafkacat
- Купа адмінок, моніторінгів і т.п.
- Дивись `awesome-kafka` у гуглі

---

# RabbitMQ?

- Нема історії
- Складні помилки
- Гірша екосистема
- Повільніше з усіх боків

---

# Альтернативи

- RabbitMQ Streams
- Apache Pulsar
- NATS JetStream

---

# Альтернатива для маленьких

## .center[RDBMS Demo]

---

# Ще

- ksqlDB
- Kafka Streams
